package extractfeature

import (

  "testing"
  "image"

)

func TestVerticalLinePositions( t* testing.T )  {

  cases := []struct {
    h1, h2 int
		value0   *image.Gray16
		expected []uint16
	}{
		{
      h1: 0,
      h2: 1,
			value0: &image.Gray16{
				Rect:   image.Rect(0, 0, 6, 6),
				Stride: 2*6,
				Pix: []uint8{
					0x08, 0x80, 0xFF, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0xFF, 0x08, 0x80,
					0x08, 0xFF, 0x08, 0x80, 0x08, 0xFF, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80,
          0x08, 0x80, 0xFF, 0x80, 0x08, 0x80, 0xFF, 0x80, 0x08, 0x80, 0x08, 0x80,
          0xFF, 0x80, 0x08, 0x80, 0x08, 0xFF, 0x08, 0x80, 0x08, 0x80, 0x08, 0x80,
				},
			},
			expected: []uint16{1,4},
		},
    {
      h1: 0,
      h2: 1,
			value0: &image.Gray16{
				Rect:   image.Rect(0, 0, 12, 1),
				Stride: 2*12,
				Pix: []uint8{
					0x08, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,
				},
			},
			expected: []uint16{1,8},
		},
    {
      h1: 0,
      h2: 1,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 12, 1),
        Stride: 2*12,
        Pix: []uint8{
          0x08, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,        },
      },
      expected: []uint16{2,8},
    },
    {
      h1: 0,
      h2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 12, 2),
        Stride: 2*12,
        Pix: []uint8{
          0x08, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,
          0x08, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,
        },
      },
      expected: []uint16{2,8},
    },
    {
      h1: 0,
      h2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 12, 2),
        Stride: 2*12,
        Pix: []uint8{
          0x08, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,
          0x08, 0x80, 0xFF, 0x80, 0x00, 0x80, 0x80, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,
        },
      },
      expected: []uint16{2,8},
    },
    {
      h1: 0,
      h2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 12, 2),
        Stride: 2*12,
        Pix: []uint8{
          0x08, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0xFF, 0x00, 0x08, 0x80, 0x08, 0x00, 0x08, 0x80,
          0x08, 0x80, 0xFF, 0x80, 0x00, 0x80, 0x80, 0x80, 0x08, 0x00, 0x08, 0x80, 0x08, 0x80, 0x00, 0x80, 0x00, 0x00, 0x08, 0x80, 0xFF, 0x00, 0x08, 0x80,
        },
      },
      expected: []uint16{2,9},
    },
	}

	for _, c := range cases {
		actual := VerticalLinePositions(c.value0,c.h1,c.h2)
    for pos, value := range actual {
      if value != c.expected[pos] {
        t.Errorf("%s: \nexpected:%v\nactual:%v\n", "VPos fist row: ", c.expected[pos], value)
      }
    }
	}

}

func TestHorizontalLinePosition( t* testing.T )  {

  cases := []struct {
    w1, w2 int
		value0   *image.Gray16
		expected []uint16
	}{
    {
      w1: 0,
      w2: 1,
			value0: &image.Gray16{
				Rect:   image.Rect(0, 0, 1, 12),
				Stride: 2*1,
				Pix: []uint8{
					0x00, 0x80,
          0x00, 0x80,
          0x00, 0x80,
          0x00, 0x80,
          0xFF, 0x00,
          0x00, 0x80,
          0x00, 0x80,
          0x00, 0x80,
          0xFF, 0x00,
          0x00, 0x80,
          0x00, 0x80,
          0x00, 0x80,
				},
			},
			expected: []uint16{4,8},
		},
    {
      w1: 0,
      w2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 2, 12),
        Stride: 2*2,
        Pix: []uint8{
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0xFF, 0x00, 0xFF, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0xFF, 0x00, 0xFF, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x08, 0x00, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
        },
      },
      expected: []uint16{4,8},
    },
    {
      w1: 0,
      w2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 2, 12),
        Stride: 2*2,
        Pix: []uint8{
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0xFF, 0x80, 0x00, 0x80,
          0xFF, 0x80, 0xFF, 0x80,
          0xFF, 0x80, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0xFF, 0x00, 0xFF, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x08, 0x00, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
        },
      },
      expected: []uint16{4,8},
    },
    {
      w1: 0,
      w2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 2, 12),
        Stride: 2*2,
        Pix: []uint8{
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0xFF, 0x80, 0x00, 0x80,
          0xFF, 0x80, 0xFF, 0x80,
          0xFF, 0x80, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x00, 0xFF, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0xFF, 0x00, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
        },
      },
      expected: []uint16{4,9},
    },
    {
      w1: 0,
      w2: 2,
      value0: &image.Gray16{
        Rect:   image.Rect(0, 0, 2, 12),
        Stride: 2*2,
        Pix: []uint8{
          0xFF, 0x80, 0x00, 0x80,
          0xFF, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x80, 0x80, 0x00, 0x80,
          0x00, 0x80, 0xFF, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0x00, 0x80, 0x00, 0x80,
          0x00, 0x00, 0xFF, 0x80,
          0x08, 0x80, 0x00, 0x80,
          0xFF, 0x00, 0x00, 0x80,
          0x08, 0x80, 0x00, 0x80,
        },
      },
      expected: []uint16{3,9},
    },
	}

	for _, c := range cases {
		actual := HorizontalLinePosition(c.value0,c.w1,c.w2)
    for pos, value := range actual {
      if value != c.expected[pos] {
        t.Errorf("%s: \nexpected:%v\nactual:%v\n", "HPos: ", c.expected[pos], value)
      }
    }
	}

}
